# 编译原理笔记

## 第一章：绪论

![image](https://github.com/bonjour-npy/Image-Hosting-Service/blob/main/typora_images/Fq_mAL2_G19wtIZSMHEoKcBe6Y4K.png?raw=true)

1. 编译程序的逻辑结构：
   - 词法分析：分析输入串如何构成句子，得到单词序列
   - 语法分析：分析单词序列如何构成程序，构造语法分析树
   - 语义分析：审查语义错误，为代码生成收集类型信息
   - 中间代码生成
   - 代码优化
   - 目标代码生成
   - 表管理、错误检查和处理贯穿**整个过程**
   
   ![image](https://github.com/bonjour-npy/Image-Hosting-Service/blob/main/typora_images/FiP05XBQ5gzerE-DFd0vT1QOUrE8.png?raw=true)
   
2. 前端和后端：

   - 前端是指与源语言有关、与目标机无关的部分

     如词法分析、语法分析、语义分析、中间代码生成、代码优化中与机器无关的部分

   - 后端是指与目标机有关的部分

     如代码优化中与机器有关的部分、目标代码的生成

3. 遍是指从头到尾扫描一遍源程序

---

## 第二章：文法和语言

1. 句型：若从文法的开始符号存在以下推导
   $$
   S \Rightarrow^* \alpha,\space \alpha \in (V_T \cup V_N)^* \tag{1}
   $$
   

   则称$\alpha$为该文法的一个句型，句型中既可以包含终结符，也可以包含非终结符，也可以是空串

2. 句子：
   $$
   S \Rightarrow^* \beta,\space \beta \in V_T^* \tag{2}
   $$
   则称$\beta$是该文法的句子

3. 文法的分类：

   1. 0型文法，又称无限制文法、短语文法

   2. 1型文法，又称文有关文法

   3. 2型文法，又称上下文无关文法（Context-Free Grammar，CFG）

      可用来构建语法树，语法树是上下文无关文法推导和规约的图形化表示
      $$
      \Alpha \rightarrow \beta,\space \Alpha \in V_N, \space \beta \in (V_T \cup V_N)^* \tag{3}
      $$

   4. 3型文法，又称正规文法（Regular Grammar，RG）

      1. 左线性文法
      2. 右线性文法

      ![image](https://changjiang-private-qn.yuketang.cn/slide/6176022/cover610_20230308101609.jpg?e=1685266663&token=IAM-gs8ue1pDIGwtR1CR0Zjdagg7Q2tn5G_1BqTmhmqa:M-MSfKPJMNwtjjZJ-uMpVhbBBEI=)

4. 最左/右推导：

   如果在推导的任何一步都是对产生式左部中的最左/右非终结符进行替换，则称为最左/右推导，其中最右推导也被成为规范推导

---

## 第三章：词法分析

1. 正规文法转换成正规式

   ![image](https://changjiang-private-qn.yuketang.cn/slide/6176022/cover685_20230308101616.jpg?e=1685266663&token=IAM-gs8ue1pDIGwtR1CR0Zjdagg7Q2tn5G_1BqTmhmqa:POqsdgFbT44awFYbziL60gZTn-s=)

2. 有穷自动机（FA）

   ![image](https://changjiang-private-qn.yuketang.cn/slide/6176022/cover682_20230308101544.jpg?e=1685266663&token=IAM-gs8ue1pDIGwtR1CR0Zjdagg7Q2tn5G_1BqTmhmqa:kwYHerbpjMYeBQSk5q6PAJWMsr4=)

   1. 确定的有穷自动机（DFA）

      1. DFA的定义及组成

         ![image](https://changjiang-private-qn.yuketang.cn/slide/6176022/cover693_20230308101546.jpg?e=1685266663&token=IAM-gs8ue1pDIGwtR1CR0Zjdagg7Q2tn5G_1BqTmhmqa:Zhk5Lg0OToBfeaOHaDwzxP-3v5E=)

      2. 确定的含义：在状态转换的每一步，FA根据当前的状态及扫描的输入字符，便能唯一地知道FA的下一状态。

         :::tip
         在状态转换图中的直观体现就是，在确定行表示的当前状态以及列确定的路径后，得到的目的状态不会是元素个数大于1的集合。
         :::

      3. DFA的可接受以及接受集的定义：从开始状态开始，经过该符号串表示的路径，若能到达终态则称该符号串可被改DFA接受。

         ![image](https://changjiang-private-qn.yuketang.cn/slide/6176022/cover704_20230308101549.jpg?e=1685266663&token=IAM-gs8ue1pDIGwtR1CR0Zjdagg7Q2tn5G_1BqTmhmqa:yP4IZcv8kIDzBomTJ_neWaeIE4Y=)

   2. 不确定的有穷自动机（NFA）

   3. `NFA的确定化`，即将NFA转换为DFA（子集法）

      ![image](https://changjiang-private-qn.yuketang.cn/slide/6176022/cover757_20230306101537.jpg?e=1685275247&token=IAM-gs8ue1pDIGwtR1CR0Zjdagg7Q2tn5G_1BqTmhmqa:e5QFa0-uM0we38hW9TKKbBzpJ2k=)

      步骤：

      1. 画出DFA转换表

         :::tip
         转换表中在状态一列中，状态包含原NFA终态的集合要标*，代表其为等价DFA的终态
         :::

         1. 计算$move(T, a)$
         2. 计算$\epsilon -closure(T)$

      2. 为转换表中的状态重命名

      3. 确定初态和终态

   4. `DFA的最小化`（分割法）

      步骤如下：

      ![image](https://changjiang-private-qn.yuketang.cn/slide/6176022/cover740_20230306101543.jpg?e=1685275247&token=IAM-gs8ue1pDIGwtR1CR0Zjdagg7Q2tn5G_1BqTmhmqa:pqG5ecvx8aUDT_ju3bRlXN-w0sM=)

      :::tip
      考试时注意过程怎么写，下面使用需要三轮分割的列子演示步骤
      :::

      ![image](https://changjiang-private-qn.yuketang.cn/slide/6176022/cover741_20230306101543.jpg?e=1685275247&token=IAM-gs8ue1pDIGwtR1CR0Zjdagg7Q2tn5G_1BqTmhmqa:zeWr7_NTnDd39JD1GttMehFK60I=)

      ![image](https://changjiang-private-qn.yuketang.cn/slide/6176022/cover742_20230306101544.jpg?e=1685275247&token=IAM-gs8ue1pDIGwtR1CR0Zjdagg7Q2tn5G_1BqTmhmqa:b17jDKj3bj_8lgWohXrlMTJJNeM=)

      ![image](https://changjiang-private-qn.yuketang.cn/slide/6176022/cover760_20230306101544.jpg?e=1685275247&token=IAM-gs8ue1pDIGwtR1CR0Zjdagg7Q2tn5G_1BqTmhmqa:JLlp-xFLt4hC8csApuld3RcLf2w=)

      在分割完成后，对可以化简的集合选出一个状态作为代表，删除其他多余状态，重新画图

      ![image](https://changjiang-private-qn.yuketang.cn/slide/6176022/cover763_20230306101545.jpg?e=1685275247&token=IAM-gs8ue1pDIGwtR1CR0Zjdagg7Q2tn5G_1BqTmhmqa:wAIdt8mMT_jxdCkyEvDL0z5OBXQ=)

3. 正规式RE与有穷自动机FA的互相转化

   ![image](https://changjiang-private-qn.yuketang.cn/slide/6176022/cover804_20230315082029.jpg?e=1685278376&token=IAM-gs8ue1pDIGwtR1CR0Zjdagg7Q2tn5G_1BqTmhmqa:kLztQKdZ8Kbqpq80aSxfjZVoNXc=)

4. 正规文法RM与有穷自动机FA的互相转化

   ![image](https://changjiang-private-qn.yuketang.cn/slide/6176022/cover770_20230315082034.jpg?e=1685278376&token=IAM-gs8ue1pDIGwtR1CR0Zjdagg7Q2tn5G_1BqTmhmqa:7JE-gomGtJXUN8XknY_oLc7wiN8=)

## 第四章：自顶向下语法分析方法

描述程序语法结构的规则可以使用`2型文法（上下文无关语法，CFG）`

语法分析方法包含确定的和不确定的分析方法，确定的语法分析方法`根据输入符号，唯一选择产生式`

确定的自顶向下分析方法：根据当前的输入符号`唯一地`确定选用哪个产生式`替换相应的非终结符`以往下推导

![image](https://changjiang-private-qn.yuketang.cn/slide/6176022/cover1171_20230322101517.jpg?e=1685279990&token=IAM-gs8ue1pDIGwtR1CR0Zjdagg7Q2tn5G_1BqTmhmqa:LmU0rDSljlj3vXP-qPR8BkhQEWY=)

1. FIRST集的定义

   ![image](https://changjiang-private-qn.yuketang.cn/slide/6176022/cover1134_20230322101439.jpg?e=1685279990&token=IAM-gs8ue1pDIGwtR1CR0Zjdagg7Q2tn5G_1BqTmhmqa:bAJ3O8-Ogp2shJmEUWUA_wIv74Q=)

2. Follow集的定义

3. SELECT集的定义
